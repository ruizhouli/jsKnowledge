### 正则表达式
 -  专门用来检索字符串的一种规则（更擅长处理模糊范围的字符串）

 - 两种写法
   + 字面量的写法 //

   + new RegExp(可以为字符串或者变量，可以进行字符串拼接，修饰符) 

 - 通过我们什么时候用这个字面量什么时候用new实例的写法

    + /aa/正则里面放的是不带引号的字符串aa

    + new RegExp(aa) 这个aa代表得是变量;

 - \代表转义字符把正则中特殊的字符转义成字符本身;(不再有任何特殊的含义),转义符转的是\后面的字符

### 正则身上的方法
 
 - exec: 找到正则匹配的字符串（首次出现的字符(就一次)），并且放到数组中(返回的是数组)
    + 数组的参数设置 ["C", index: 10, input: "lsnsnw1122CCSAFzAzZ", groups: undefined]  "C"为要匹配的字符  index:10 为"C"首   次出现的位置  input: "lsnsnw1122CCSAFzAzZ" 在哪个字符串中查找 groups:undefined  length:1

 - test:测试某个字符串是否符合正则规则  符合的话返回true 否则返回false
 
 #### 特殊转义字符
 - \d 特殊转义字符 (一个0-9之间的数)

 - \D 一个非数字

 #### 量词

 - +：至少出现一次 多的不限

 - *：出现0-多次

 - ?:出现0-1次

 - {}：代表花括号前面的量出现的次数
    + {m,} 至少出现m次 最多不限
    + {m,n}最少出现m次，最多出现n次
    + {m}出现了m次
 #### 修饰符

 - g全局匹配

 - i不区分大小写

 ### 字符串的方法可以和正则结合功能更强大

 - string.march()找到正则匹配的字符并且把它们放到数组中（返回值是数组） 和exec相似

 -  懒惰: 
            你让它找一个，绝对不会找第二个，你让它找一堆，它绝对不会找第二堆

 -  贪婪:
            只要符合某个规则就不停的找，直到找不到为止
 
 - string.replace() 括号中两个参数 第一个参数为 ''或者是正则  第二个参数为被替换的字符串或着方法

    +  replace*默认*情况下，函数的
                第一个参数是每次匹配字符
                第二个参数是匹配字符索引
                第三个参数是整个字符串
                第四个参数是undefined 

    + 如果有分组的情况，函数的
                第一个参数是每次匹配字符
                第二个参数是第一个分组，
                之后有几个分组，参数就是分组项
                直到分组读完就正常走索引、整个字符串、undefined

    + 分组 ()从左往右数    如果分组的后面有量词，那么分组项为最后一个字符

### []的用法

 -  []中的字符在正则中是表示匹配任意一个字符

    + [123]代表匹配123中的任意一个

    + [0-9] -> \d  ascll码来编排的

    + [a-z]小写英文

    + [A-Z]大写英文

    + 不能写成[A-z];因为他们是按照ascII来编排的在这个范围里面除了大小写字母它还包含了其他字符

    + ^代表以什么开头 $代表以什么结尾

### ^

- 当^放在[]里面代表除了
   ```
   let str = 'a123s21b6a12d1b6d5ba12b';
    // /a[^12]b/g
    console.log(str.match(/a[^12]+b/g))//以a开头b结尾 中间除了1
   ```

 


