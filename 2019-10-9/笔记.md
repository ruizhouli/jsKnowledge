### 作用域
   - 运行js代码的范围
   - 作用域分为全局作用域和局部作用域
     - 全局作用域
     ```
     当打开浏览器的时候,解读到script标签的时候，会把js代码运行在window全局作用域下 全局会生成一个全局活动对象将这些变量、函数都放到这个对象下面，整个window下的环境都叫全局作用域，所以一个变量一个函数都默认在window下

     比如：console.log(window.a); //如果没有使用var声明变量，在赋值之前是不会把a挂在window上的，所以a是找不到的
           a = 10;
          console.log(window);//赋值之后window下就有a
     ```
     - 局部作用域
     ```
     在运行函数的时候，函数内部会开辟一个执行栈，在执行栈中会创建一个活动变量的对象，会把函数中所有变量、函数存储到这个活动变量下，执行栈去运行这个活动变量，这些活动变量下的变量、函数***只会作用在函数内***这种现象就叫局部作用域
     ```
### 作用域链
   当在一个函数中访问不到一个变量时 首先会去参数中找 如果找不到 就去父级中去找 如果还是找不到 就再往上一级找 直到window 如果还找不到的话 就报错
### 局部作用域运行
     - 如果没有形参的话，函数体内有var如果在var的上面去访问这个变量结果为undefined

     - 如果有形参并且也有实参 也有var 如果在var的上面去访问这个变量结果为实参

     - 如果函数内有函数，有形参并且也有实参，那么结果就为函数内有函数
### 变量提升（预解析机制）
    当浏览器去解析js代码的时候 会提前去解析全局的var和函数
    解读代码的时候一定要记住以下两步:
    第一步:
        上来就找var和function声明 然后进行比较

        比较的规则是：函数大于变量 下面的函数会覆盖上面的函数

    第二步:
        逐行解读代码，此时var和function声明就不用再去读了，
        一般读的是赋值(=)，计算，输出，判断..

```
一个匿名函数自执行 如果函数体内的变量名与函数名相同 不管给这个变量赋值什么 打印出来还是这个有名函数

比如：
var fun = 20;
   +function fun(){
       fun=10;
       console.log(fun);
   }()
```
### var let const之间的区别

- var 可以允许有两个同名的变量 可以变量提升 不支持块级作用域 存到全局的活动变量中 

- let 不允许有两个同名的变量   不可以变量提升且有暂存死区 支持块级作用域  不会存到全局的活动变量中 

- const 不允许有两个同名的变量  不可以变量提升且有暂存死区  不会存到全局的活动变量中  值是不能被改变且声明了必须赋值

在代码块内，使用let命令声明变量之前，该变量都是不可用的。这在语法上，称为“暂时性死区”（temporal dead zone，简称 TDZ）。

### 块级作用域
    {
        console.log(a); //在上方访问块中的函数a，结果undefined
        if(a){
            console.log(1)
        }else{
            console.log(2)
        }
        {
            //这个函数在块中，在预解析的时候会undefined
            function a(){}
        }
        console.log(a);
    }
